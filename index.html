<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Piano Blocks Infinite</title>
  <style>
    :root {
      --green: #00ff66;
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    /* ---- TŁO: fade między zielonym i czarnym ---- */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -2;
      background: radial-gradient(circle at center, #000 0%, var(--green) 100%);
      animation: bgFade 8s ease-in-out infinite alternate;
      opacity: 0.8;
    }

    @keyframes bgFade {
      0%   { background: radial-gradient(circle at center, #000 0%, var(--green) 100%); opacity: 0.8; }
      50%  { background: radial-gradient(circle at center, var(--green) 0%, #000 100%); opacity: 0.3; }
      100% { background: radial-gradient(circle at center, #000 0%, var(--green) 100%); opacity: 0.8; }
    }

    canvas {
      display: block;
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script>
    const canvas = document.getElementById('bg-canvas');
    const scene = new THREE.Scene();

    // ---- Kamera ----
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 3, 10); // oddalenie kamery, aby zmieścić dłuższe klocki
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // ---- Światła ----
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7);
    scene.add(amb, dir);

    // ---- Parametry klocków ----
    const cols = 28;
    const spacing = 0.9;
    const baseWidth = 0.8;
    const baseDepth = 5;
    const baseHeight = 0.3;

    const visibleGroups = 3;
    const totalCols = cols * visibleGroups;
    const totalWidth = cols * spacing;

    const blocks = [];
    const group = new THREE.Group();
    scene.add(group);

    for (let i = 0; i < totalCols; i++) {
      const geom = new THREE.BoxGeometry(baseWidth, baseHeight, baseDepth);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x000000,
        metalness: 0.3,
        roughness: 0.4
      });
      const mesh = new THREE.Mesh(geom, mat);

      const edges = new THREE.EdgesGeometry(geom);
      const lines = new THREE.LineSegments(
        edges,
        new THREE.LineBasicMaterial({ color: 0x00ff66 })
      );

      const wrapper = new THREE.Group();
      wrapper.add(mesh);
      wrapper.add(lines);

      wrapper.position.set(i * spacing - totalWidth, baseHeight / 2, -1);
      group.add(wrapper);

      blocks.push({
        obj: wrapper,
        offset: Math.random() * Math.PI * 2,
        speed: 0.8 + Math.random() * 0.2
      });
    }

    // ---- Prędkość scrollu ----
    const scrollTime = 10; // sekundy na pełne przesunięcie
    const scrollSpeed = totalWidth / scrollTime;

    const clock = new THREE.Clock();

    function animate() {
      const delta = clock.getDelta();
      const t = clock.elapsedTime;

      // Ruch wszystkich klocków w prawo
      for (let b of blocks) {
        const obj = b.obj;
        obj.position.x += scrollSpeed * delta;
        if (obj.position.x > totalWidth) {
          obj.position.x -= totalWidth * visibleGroups; // powrót na początek
        }

      // ---- Animacja falowa z tween (unoszenie i opadanie) ----
const waveDuration = 2; // sekundy na zmianę grup
const raiseTime = 0.5;   // ile sekund trwa unoszenie
const fallTime = 1.0;    // ile sekund trwa opadanie
const waveHeight = 0.3;  // maksymalna wysokość unoszenia

const tTotal = clock.getElapsedTime();
const cycle = Math.floor(tTotal / waveDuration) % 2; // dwie grupy 0 i 1
const tInCycle = tTotal % waveDuration;

for (let i = 0; i < blocks.length; i++) {
  const b = blocks[i];
  const groupIndex = i % 2; // 0 lub 1 na przemian

  let targetY = baseHeight / 2;

  if (groupIndex === cycle) {
    // aktywna grupa - unoszenie
    if (tInCycle < raiseTime) {
      // liniowe unoszenie
      targetY += waveHeight * (tInCycle / raiseTime);
    } else {
      // po osiągnięciu szczytu lekko opada
      targetY += waveHeight * (1 - ((tInCycle - raiseTime) / (waveDuration - raiseTime)));
    }
  } else if (groupIndex === (cycle + 1) % 2) {
    // poprzednia grupa - wolne opadanie
    if (tInCycle < fallTime) {
      targetY += waveHeight * 0.3 * (1 - tInCycle / fallTime);
    }
  }

  // interpolacja, aby ruch był płynny
  b.obj.position.y += (targetY - b.obj.position.y) * 0.1;
}

      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // ---- Responsywność ----
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

